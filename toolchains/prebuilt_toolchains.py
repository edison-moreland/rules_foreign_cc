#!/usr/bin/env python3

import hashlib
import json
import urllib.request
from pathlib import Path
from textwrap import indent

CMAKE_SHA256_URL_TEMPLATE = "https://cmake.org/files/v{minor}/cmake-{full}-SHA-256.txt"
CMAKE_URL_TEMPLATE = "https://github.com/Kitware/CMake/releases/download/v{full}/{file}"

CMAKE_VERSIONS = [
    "3.23.2",
    "3.23.1",
    "3.22.4",
    "3.22.3",
    "3.22.2",
    "3.22.1",
    "3.22.0",
    "3.21.5",
    "3.21.4",
    "3.21.3",
    "3.21.2",
    "3.21.1",
    "3.21.0",
    "3.20.5",
    "3.20.4",
    "3.20.3",
    "3.20.2",
    "3.20.1",
    "3.20.0",
    "3.19.8",
    "3.19.7",
    "3.19.6",
    "3.19.5",
    "3.18.6",
    "3.17.5",
    "3.16.9",
    "3.15.7",
    "3.14.7",
    "3.13.5",
    "3.12.4",
    "3.11.4",
    "3.10.3",
    "3.9.6",
    "3.8.2",
    "3.7.2",
    "3.6.3",
    "3.5.2",
    "3.4.3",
    "3.3.2",
    "3.2.3",
    "3.1.3",
    "3.0.2",
]

CMAKE_TARGETS = {
    "Darwin-x86_64": [
        "@platforms//cpu:x86_64",
        "@platforms//os:macos",
    ],
    "linux-aarch64": [
        "@platforms//cpu:aarch64",
        "@platforms//os:linux",
    ],
    "linux-x86_64": [
        "@platforms//cpu:x86_64",
        "@platforms//os:linux",
    ],
    "Linux-aarch64": [
        "@platforms//cpu:aarch64",
        "@platforms//os:linux",
    ],
    "Linux-x86_64": [
        "@platforms//cpu:x86_64",
        "@platforms//os:linux",
    ],
    "macos-universal": [
        "@platforms//os:macos",
    ],
    "windows-i386": [
        "@platforms//cpu:x86_32",
        "@platforms//os:windows",
    ],
    "windows-x86_64": [
        "@platforms//cpu:x86_64",
        "@platforms//os:windows",
    ],
    "win32-x86": [
        "@platforms//cpu:x86_32",
        "@platforms//os:windows",
    ],
    "win64-x64": [
        "@platforms//cpu:x86_64",
        "@platforms//os:windows",
    ],
}

NINJA_URL_TEMPLATE = (
    "https://github.com/ninja-build/ninja/releases/download/v{full}/ninja-{target}.zip"
)

NINJA_TARGETS = {
    "linux": [
        "@platforms//cpu:x86_64",
        "@platforms//os:linux",
    ],
    "mac": [
        "@platforms//cpu:x86_64",
        "@platforms//os:macos",
    ],
    "win": [
        "@platforms//cpu:x86_64",
        "@platforms//os:windows",
    ],
}

NINJA_VERSIONS = (
    "1.11.0",
    "1.10.2",
    "1.10.1",
    "1.10.0",
    "1.9.0",
    "1.8.2",
)



PKG_CONFIG_URL_TEMPLATE = (
    "https://download.gnome.org/binaries/win64/dependencies/pkg-config_{full}-{revision}_win64.zip"
)

PKG_CONFIG_TARGETS = {
    "win": [
        "@platforms//cpu:x86_64",
        "@platforms//os:windows",
    ],
}

PKG_CONFIG_VERSIONS = (
    "0.23",
)

PKG_CONFIG_URLS = {
    "gettext": "https://download.gnome.org/binaries/win64/dependencies/gettext-runtime_0.18.1.1-2_win64.zip",
    "glib": "https://download.gnome.org/binaries/win64/glib/2.26/glib_2.26.1-1_win64.zip"
}


REPO_DEFINITION = """\
maybe(
    http_archive,
    name = "{name}",
    urls = [
        "{url}",
    ],
    sha256 = "{sha256}",
    strip_prefix = "{prefix}",
    build_file_content = {template}.format(
        bin = "{bin}",
        env = "{env}",
    ),
)
"""

TOOLCHAIN_REPO_DEFINITION = """\
# buildifier: leave-alone
maybe(
    prebuilt_toolchains_repository,
    name = "{name}",
    repos = {repos},
    tool = "{tool}",
)
"""

REGISTER_TOOLCHAINS = """\
if register_toolchains:
    native.register_toolchains(
{toolchains}
    )
"""

BZL_FILE_TEMPLATE = """\
\"\"\" A U T O G E N E R A T E D  -- D O   N O T   M O D I F Y
@generated

This file is generated by prebuilt_toolchains.py
\"\"\"

load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")
load("@bazel_tools//tools/build_defs/repo:utils.bzl", "maybe")
load("@rules_foreign_cc//toolchains:prebuilt_toolchains_repository.bzl", "prebuilt_toolchains_repository")

_CMAKE_BUILD_FILE = \"\"\"\\
load("@rules_foreign_cc//toolchains/native_tools:native_tools_toolchain.bzl", "native_tool_toolchain")

package(default_visibility = ["//visibility:public"])

filegroup(
    name = "cmake_data",
    srcs = glob(
        [
            "**",
        ],
        exclude = [
            "WORKSPACE",
            "WORKSPACE.bazel",
            "BUILD",
            "BUILD.bazel",
        ],
    ),
)

native_tool_toolchain(
    name = "cmake_tool",
    path = "bin/{{bin}}",
    target = ":cmake_data",
)
\"\"\"

_NINJA_BUILD_FILE = \"\"\"\\
load("@rules_foreign_cc//toolchains/native_tools:native_tools_toolchain.bzl", "native_tool_toolchain")

package(default_visibility = ["//visibility:public"])

filegroup(
    name = "ninja_bin",
    srcs = ["{{bin}}"],
)

native_tool_toolchain(
    name = "ninja_tool",
    env = {{env}},
    path = "$(execpath :ninja_bin)",
    target = ":ninja_bin",
)
\"\"\"

_PKG_CONFIG_BUILD_FILE = \"\"\"\\
load("@rules_foreign_cc//toolchains/native_tools:native_tools_toolchain.bzl", "native_tool_toolchain")

package(default_visibility = ["//visibility:public"])

filegroup(
    name = "pkg_config_bin",
    srcs = ["{{bin}}", "glib.dll", "gettext.dll"],
)

native_tool_toolchain(
    name = "pkg_config_tool",
    env = {{env}},
    path = "$(execpath :pkg_config_bin)",
    target = ":pkg_config_bin",
)
\"\"\"

_GLIB_BUILD_FILE = \"\"\"\\
load("@rules_cc//cc:defs.bzl", "cc_import")
package(default_visibility = ["//visibility:public"])

filegroup(
    name = "glib_libs",
    srcs = [":gio", ":glib", ":gmodule", "gobject", "gthread"],
)

cc_import(
    name = "gio",
    shared_library = "bin/libgio-2.0-0.dll",
)

cc_import(
    name = "glib",
    shared_library = "bin/libglib-2.0-0.dll",
)

cc_import(
    name = "gmodule",
    shared_library = "bin/libgmodule-2.0-0.dll",
)

cc_import(
    name = "gobject",
    shared_library = "bin/libgobject-2.0-0.dll",
)

cc_import(
    name = "gthread",
    shared_library = "bin/libgthread-2.0-0.dll",
)
\"\"\"

_GETTEXT_BUILD_FILE = \"\"\"\\
package(default_visibility = ["//visibility:public"])

filegroup(
    name = "gettext",
    srcs = ["gettext.dll"],
)
\"\"\"

# buildifier: disable=unnamed-macro
def prebuilt_toolchains(cmake_version, ninja_version, pkg_config_version, register_toolchains):
    \"\"\"Register toolchains for pre-built cmake and ninja binaries

    Args:
        cmake_version (string): The target cmake version
        ninja_version (string): The target ninja-build version
        register_toolchains (boolean): Whether to call native.register_toolchains or not
    \"\"\"
    _cmake_toolchains(cmake_version, register_toolchains)
    _ninja_toolchains(ninja_version, register_toolchains)
    _pkg_config_toolchains(pkg_config_version, register_toolchains)
    _make_toolchains(register_toolchains)

def _cmake_toolchains(version, register_toolchains):
{cmake_definitions}

def _ninja_toolchains(version, register_toolchains):
{ninja_definitions}

def _pkg_config_toolchains(version, register_toolchains):
{pkg_config_definitions}

def _make_toolchains(register_toolchains):
{make_definitions}
"""

def download_and_calc_sha256(url):
    # Get sha256 (can be slow)
    remote = urllib.request.urlopen(url)
    total_read = 0
    max_file_size = 100 * 1024 * 1024
    hash = hashlib.sha256()
    while True:
        data = remote.read(4096)
        total_read += 4096

        if not data or total_read > max_file_size:
            break

        hash.update(data)
    return hash.hexdigest()


def get_cmake_definitions() -> str:
    """Define a set of repositories and calls for registering `cmake` toolchains

    Returns:
        str: The Implementation of `_cmake_toolchains`
    """

    archives = []

    for version in CMAKE_VERSIONS:
        major, minor, _patch = version.split(".")

        version_archives = []
        version_toolchains = {}

        minor_version = "{}.{}".format(major, minor)
        for line in urllib.request.urlopen(
            CMAKE_SHA256_URL_TEMPLATE.format(minor=minor_version, full=version)
        ).readlines():
            line = line.decode("utf-8").strip("\n ")

            # Only take tar and zip files. The rest can't be easily decompressed.
            if not line.endswith(".tar.gz") and not line.endswith(".zip"):
                continue

            # Only include the targets we care about.
            plat_target = None
            for target in CMAKE_TARGETS.keys():
                if target in line:
                    plat_target = target
                    break

            if not plat_target:
                continue

            sha256, file = line.split()
            name = file.replace(".tar.gz", "").replace(".zip", "")
            bin = "cmake.exe" if "win" in file.lower() else "cmake"

            if "Darwin" in file or "macos" in file:
                prefix = name + "/CMake.app/Contents"
            else:
                prefix = name

            version_archives.append(
                REPO_DEFINITION.format(
                    name=name,
                    sha256=sha256,
                    prefix=prefix,
                    url=CMAKE_URL_TEMPLATE.format(full=version, file=file),
                    build="cmake",
                    template="_CMAKE_BUILD_FILE",
                    bin=bin,
                    env="{}",
                )
            )
            version_toolchains.update({plat_target: name})

        archives.append(
            "\n".join(
                [
                    '    if "{}" == version:'.format(version),
                ]
                + [indent(archive, " " * 8) for archive in version_archives]
            )
        )

        toolchains_repos = {}
        for target, name in version_toolchains.items():
            toolchains_repos.update({name: CMAKE_TARGETS[target]})

        archives.append(
            indent(
                TOOLCHAIN_REPO_DEFINITION.format(
                    name="cmake_{}_toolchains".format(version),
                    repos=indent(
                        json.dumps(toolchains_repos, indent=4), " " * 4
                    ).lstrip(),
                    tool="cmake",
                ),
                " " * 8,
            )
        )

        archives.append(
            indent(
                REGISTER_TOOLCHAINS.format(
                    toolchains="\n".join(
                        [
                            indent(
                                '"@cmake_{}_toolchains//:{}_toolchain",'.format(
                                    version, repo
                                ),
                                " " * 8,
                            )
                            for repo in toolchains_repos
                        ]
                    )
                ),
                " " * 8,
            )
        )

        archives.extend(
            [
                indent("return", " " * 8),
                "",
            ]
        )

    archives.append(indent('fail("Unsupported version: " + str(version))', " " * 4))

    return "\n".join([archive.rstrip(" ") for archive in archives])


def get_ninja_definitions() -> str:
    """Define a set of repositories and calls for registering `ninja` toolchains

    Returns:
        str: The Implementation of `_ninja_toolchains`
    """

    archives = []

    for version in NINJA_VERSIONS:

        version_archives = []
        version_toolchains = {}

        for target in NINJA_TARGETS.keys():
            url = NINJA_URL_TEMPLATE.format(
                full=version,
                target=target,
            )

            sha256 = download_and_calc_sha256(url)

            name = "ninja_{}_{}".format(version, target)

            version_archives.append(
                REPO_DEFINITION.format(
                    name=name,
                    url=url,
                    sha256=sha256,
                    prefix="",
                    build="ninja",
                    template="_NINJA_BUILD_FILE",
                    bin="ninja.exe" if "win" in target else "ninja",
                    env='{\\"NINJA\\": \\"$(execpath :ninja_bin)\\"}',
                )
            )
            version_toolchains.update({target: name})

        archives.append(
            "\n".join(
                [
                    '    if "{}" == version:'.format(version),
                ]
                + [indent(archive, " " * 8) for archive in version_archives]
            )
        )

        toolchains_repos = {}
        for target, name in version_toolchains.items():
            toolchains_repos.update({name: NINJA_TARGETS[target]})

        archives.append(
            indent(
                TOOLCHAIN_REPO_DEFINITION.format(
                    name="ninja_{}_toolchains".format(version),
                    repos=indent(
                        json.dumps(toolchains_repos, indent=4), " " * 4
                    ).lstrip(),
                    tool="ninja",
                ),
                " " * 8,
            )
        )

        archives.append(
            indent(
                REGISTER_TOOLCHAINS.format(
                    toolchains="\n".join(
                        [
                            indent(
                                '"@ninja_{}_toolchains//:{}_toolchain",'.format(
                                    version, repo
                                ),
                                " " * 8,
                            )
                            for repo in toolchains_repos
                        ]
                    )
                ),
                " " * 8,
            )
        )

        archives.extend(
            [
                indent("return", " " * 8),
                "",
            ]
        )

    archives.append(indent('fail("Unsupported version: " + str(version))', " " * 4))

    return "\n".join(archives)

def get_pkg_config_definitions() -> str:
    """Define a set of repositories and calls for registering `pkg_config` toolchains

    Returns:
        str: The Implementation of `_pkg_config_toolchains`
    """

    archives = []

    for version in PKG_CONFIG_VERSIONS:

        version_archives = []
        version_toolchains = {}

        archives.append(indent('''\
maybe(
    http_archive,
    name = "{name}",
    urls = [
        "{url}",
    ],
    sha256 = "{sha256}",
    strip_prefix = "{prefix}",
    build_file_content = {template}
)
'''.format(
    name="gettext",
    url=PKG_CONFIG_URLS["gettext"],
    sha256=download_and_calc_sha256(PKG_CONFIG_URLS["gettext"]),
    prefix="",
    template="_GETTEXT_BUILD_FILE"
)," " * 4))

        archives.append(indent('''\
maybe(
    http_archive,
    name = "{name}",
    urls = [
        "{url}",
    ],
    sha256 = "{sha256}",
    strip_prefix = "{prefix}",
    build_file_content = {template}
)
'''.format(
    name="glib",
    url=PKG_CONFIG_URLS["glib"],
    sha256=download_and_calc_sha256(PKG_CONFIG_URLS["glib"]),
    prefix="",
    template="_GLIB_BUILD_FILE"
)," " * 4))
       

        for target in PKG_CONFIG_TARGETS.keys():
            url = PKG_CONFIG_URL_TEMPLATE.format(
                full=version,
                revision=2,
            )

            sha256 = download_and_calc_sha256(url)

            name = "pkg_config_{}_{}".format(version, target)

            version_archives.append(
                REPO_DEFINITION.format(
                    name=name,
                    url=url,
                    sha256=sha256,
                    prefix="",
                    build="pkg_config",
                    template="_PKG_CONFIG_BUILD_FILE",
                    bin="pkg_config.exe",
                    env='{\\"PKG_CONFIG\\": \\"$(execpath :pkg_config_bin)\\"}',
                )
            )
            version_toolchains.update({target: name})

        archives.append(
            "\n".join(
                [
                    '    if "{}" == version:'.format(version),
                ]
                + [indent(archive, " " * 8) for archive in version_archives]
            )
        )

        toolchains_repos = {}
        for target, name in version_toolchains.items():
            toolchains_repos.update({name: PKG_CONFIG_TARGETS[target]})

        archives.append(
            indent(
                TOOLCHAIN_REPO_DEFINITION.format(
                    name="pkg_config_{}_toolchains".format(version),
                    repos=indent(
                        json.dumps(toolchains_repos, indent=4), " " * 4
                    ).lstrip(),
                    tool="pkgconfig",
                ),
                " " * 8,
            )
        )

        archives.append(
            indent(
                REGISTER_TOOLCHAINS.format(
                    toolchains="\n".join(
                        [
                            indent(
                                '"@pkg_config_{}_toolchains//:{}_toolchain",'.format(
                                    version, repo
                                ),
                                " " * 8,
                            )
                            for repo in toolchains_repos
                        ]
                    )
                ),
                " " * 8,
            )
        )

        archives.extend(
            [
                indent("return", " " * 8),
                "",
            ]
        )

    archives.append(indent('fail("Unsupported version: " + str(version))', " " * 4))

    return "\n".join(archives)


def get_make_definitions() -> str:
    """Define a set of repositories and calls for registering `make` toolchains

    Returns:
        str: The Implementation of `_make_toolchains`
    """

    return indent("# There are currently no prebuilt make binaries\npass", " " * 4)


def main():
    """The main entrypoint of the toolchains generator"""
    repos_bzl_file = Path(__file__).parent.absolute() / "prebuilt_toolchains.bzl"

    repos_bzl_file.write_text(
        BZL_FILE_TEMPLATE.format(
            cmake_definitions=get_cmake_definitions(),
            ninja_definitions=get_ninja_definitions(),
            pkg_config_definitions=get_pkg_config_definitions(),
            make_definitions=get_make_definitions(),
        )
    )


if __name__ == "__main__":
    main()
